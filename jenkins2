pipeline {
    agent any

    parameters {
        string(name: 'REPO_NAME', description: 'Git repository name (same as API name)')
        string(name: 'BRANCH', defaultValue: 'main', description: 'Git branch')
        choice(name: 'ENV', choices: ['dev', 'qa', 'prod'], description: 'Target environment')
    }

    environment {
        GIT_ORG = "samaharshareddy"
        GIT_URL = "https://github.com/${GIT_ORG}/${params.REPO_NAME}.git"

        HARBOR_REGISTRY = "harborrmz.unionbankofindia.co.in"
        HARBOR_PROJECT  = "apim-mule-repo"

        IMAGE_NAME = "${params.REPO_NAME}"

        MAVEN_OPTS = "-Dmaven.repo.local=.m2/repository"
        DOCKER_CREDS = "harbor-creds"
        GIT_CREDS = "github-token"
    }

    stages {

        stage('Checkout Code') {
            steps {
                git branch: params.BRANCH,
                    url: env.GIT_URL,
                    credentialsId: env.GIT_CREDS
            }
        }

        stage('Build Mule Application') {
            steps {
                sh '''
                    mvn clean package -DskipTests
                '''
            }
        }

        stage('Run Tests') {
            steps {
                sh '''
                    mvn test
                '''
            }
        }

        stage('Resolve Artifact') {
            steps {
                script {
                    env.JAR_NAME = sh(
                        script: """
                        ls target/*.jar | grep -v 'original' | head -1
                        """,
                        returnStdout: true
                    ).trim()

                    if (!env.JAR_NAME) {
                        error "No JAR found in target directory"
                    }

                    echo "Using JAR: ${env.JAR_NAME}"
                }
            }
        }

        stage('Determine Image Version') {
            steps {
                script {
                    def latest = sh(
                        script: """
                        docker images --format '{{.Repository}}:{{.Tag}}' \
                        | grep '^${HARBOR_REGISTRY}/${HARBOR_PROJECT}/${IMAGE_NAME}:v' \
                        | awk -F:v '{print \$2}' \
                        | sort -n \
                        | tail -1
                        """,
                        returnStdout: true
                    ).trim()

                    env.IMAGE_VERSION = latest ? "v${latest.toInteger() + 1}" : "v1"

                    env.FULL_IMAGE = "${IMAGE_NAME}:${env.IMAGE_VERSION}"
                    env.HARBOR_IMAGE = "${HARBOR_REGISTRY}/${HARBOR_PROJECT}/${IMAGE_NAME}:${env.IMAGE_VERSION}"

                    echo "Image version resolved: ${env.IMAGE_VERSION}"
                }
            }
        }

        stage('Docker Build') {
            steps {
                sh '''
                    docker build \
                      --build-arg JAR_FILE=${JAR_NAME} \
                      -t ${FULL_IMAGE} .
                '''
            }
        }

        stage('Docker Push') {
            steps {
                withCredentials([usernamePassword(
                    credentialsId: env.DOCKER_CREDS,
                    usernameVariable: 'HARBOR_USER',
                    passwordVariable: 'HARBOR_PASS'
                )]) {
                    sh '''
                        echo "$HARBOR_PASS" | docker login ${HARBOR_REGISTRY} \
                            -u "$HARBOR_USER" --password-stdin

                        docker tag ${FULL_IMAGE} ${HARBOR_IMAGE}
                        docker push ${HARBOR_IMAGE}
                    '''
                }
            }
        }

        stage('Deploy (Optional)') {
            when {
                expression { params.ENV != 'dev' }
            }
            steps {
                echo "Deploying ${params.REPO_NAME} to ${params.ENV}"
                // Helm / Anypoint / ArgoCD trigger here
            }
        }
    }

    post {
        success {
            echo "✅ ${params.REPO_NAME}:${env.IMAGE_VERSION} pushed to Harbor"
        }
        failure {
            echo "❌ Pipeline failed for ${params.REPO_NAME}"
        }
        cleanup {
            sh 'docker logout || true'
        }
    }
}
