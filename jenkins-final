pipeline {
    agent any

    parameters {
        string(name: 'REPO_NAME', description: 'Git repo / API name')
        string(name: 'BRANCH', defaultValue: 'main', description: 'Git branch')
        choice(name: 'ENV', choices: ['dev', 'qa', 'prod'], description: 'Environment')
    }

    environment {
        GIT_ORG = "samaharshareddy"
        GIT_URL = "https://github.com/${GIT_ORG}/${params.REPO_NAME}.git"

        HARBOR_REGISTRY = "harborrmz.unionbankofindia.co.in"
        HARBOR_PROJECT  = "apim-mule-repo"

        IMAGE_NAME = "${params.REPO_NAME}"

        CENTRAL_DOCKER_DIR = "/opt/mule-docker"
        CENTRAL_DOCKERFILE = "/opt/mule-docker/Dockerfile"

        MAVEN_OPTS = "-Dmaven.repo.local=.m2/repository"

        GIT_CREDS = "github-token"
        DOCKER_CREDS = "harbor-creds"
    }

    stages {

        stage('Checkout Code') {
            steps {
                git branch: params.BRANCH,
                    url: env.GIT_URL,
                    credentialsId: env.GIT_CREDS
            }
        }

        stage('Build Mule Application') {
            steps {
                sh 'mvn clean package -DskipTests'
            }
        }

        stage('Resolve JAR') {
            steps {
                script {
                    env.JAR_PATH = sh(
                        script: "ls target/*.jar | grep -v original | head -1",
                        returnStdout: true
                    ).trim()

                    if (!env.JAR_PATH) {
                        error "No JAR found in target directory"
                    }

                    echo "Using JAR: ${env.JAR_PATH}"
                }
            }
        }

        stage('Prepare Docker Build Context') {
            steps {
                sh """
                    cp ${JAR_PATH} ${CENTRAL_DOCKER_DIR}/
                """
            }
        }

        stage('Resolve Image Version') {
            steps {
                script {
                    def latest = sh(
                        script: """
                        docker images --format '{{.Repository}}:{{.Tag}}' |
                        grep '^${HARBOR_REGISTRY}/${HARBOR_PROJECT}/${IMAGE_NAME}:v' |
                        awk -F:v '{print \$2}' |
                        sort -n |
                        tail -1
                        """,
                        returnStdout: true
                    ).trim()

                    env.IMAGE_VERSION = latest ? "v${latest.toInteger() + 1}" : "v1"

                    env.FULL_IMAGE = "${IMAGE_NAME}:${env.IMAGE_VERSION}"
                    env.HARBOR_IMAGE = "${HARBOR_REGISTRY}/${HARBOR_PROJECT}/${IMAGE_NAME}:${env.IMAGE_VERSION}"

                    echo "Resolved image version: ${env.IMAGE_VERSION}"
                }
            }
        }

        stage('Docker Build') {
            steps {
                sh """
                    docker build \
                      -f ${CENTRAL_DOCKERFILE} \
                      --build-arg JAR_FILE=$(basename ${JAR_PATH}) \
                      -t ${FULL_IMAGE} \
                      ${CENTRAL_DOCKER_DIR}
                """
            }
        }

        stage('Docker Push') {
            steps {
                withCredentials([usernamePassword(
                    credentialsId: env.DOCKER_CREDS,
                    usernameVariable: 'HARBOR_USER',
                    passwordVariable: 'HARBOR_PASS'
                )]) {
                    sh """
                        echo "$HARBOR_PASS" | docker login ${HARBOR_REGISTRY} \
                          -u "$HARBOR_USER" --password-stdin

                        docker tag ${FULL_IMAGE} ${HARBOR_IMAGE}
                        docker push ${HARBOR_IMAGE}
                    """
                }
            }
        }

        stage('Deploy (Optional)') {
            when {
                expression { params.ENV != 'dev' }
            }
            steps {
                echo "Deploying ${params.REPO_NAME} to ${params.ENV}"
                // ArgoCD / Helm / Anypoint hook
            }
        }
    }

    post {
        success {
            echo "${params.REPO_NAME}:${env.IMAGE_VERSION} pushed successfully"
        }
        failure {
            echo "Pipeline failed for ${params.REPO_NAME}"
        }
        cleanup {
            sh """
                rm -f ${CENTRAL_DOCKER_DIR}/*.jar || true
                docker logout || true
            """
        }
    }
}
